# Лабораторная работа №2

_Материал взят и переработан из методического указания Докторова А.Е. "Операционная система Linux", разработанного на кафедре ИВК УлГТУ для направления 23020165 "Информационные системы и технологии"._

## Справочный материал. Общая структура Linux

Операционная система Linux (как и большинство систем семейства Unix) в соответствии с режимом работы процессора может работать в режиме ядра и режиме пользователя.

Ядро непосредственно взаимодействует с аппаратной частью компьютера, изолируя прикладные программы от особенностей ее архитектуры.
Ядро имеет набор услуг, предоставляемых прикладным программам.
К услугам ядра относятся операции ввода/вывода (открытия, чтения, записи и управления файлами), создания и управления процессами, их синхронизации и межпроцессного взаимодействия.
Все приложения запрашивают услуги ядра посредством **системных вызовов**.

Уровень пользователя составляют приложения или задачи, как системные, определяющие функциональность системы, так и прикладные, обеспечивающие пользовательский интерфейс.
Однако, несмотря на внешнюю разнородность приложений, схемы их взаимодействия с ядром одинаковы.

Ядро обеспечивает базовую функциональность операционной системы: создает процессы и управляет ими, распределяет память и обеспечивает доступ к файлам и периферийным устройствам.
Взаимодействие прикладных задач с ядром происходит посредством стандартного интерфейса системных вызовов.
Интерфейс системных вызовов представляет собой набор услуг ядра и определяет формат запросов на услуги.
Процесс запрашивает услугу посредством системного вызова определенной процедуры ядра, внешне похожего на обычный вызов библиотечной функции.
Ядро от имени процесса выполняет запрос и возвращает процессу необходимые данные.

Ядро состоит из трех основных подсистем:
1. Файловая подсистема.
2. Подсистема управления процессами и памятью.
3. Подсистема ввода/вывода.

**Файловая подсистема** обеспечивает унифицированный интерфейс доступа к данным, расположенным на дисковых накопителях, и к периферийным устройствам.
Одни и те же функции `ореn(2)`, `read(2)`, могут использоваться как при чтении или записи данных на диск, так и при выводе текста на принтер или терминал.
Она контролирует права доступа к файлу, выполняет операции размещения и удаления файла, а также выполняет запись/чтение данных файла.
Поскольку большинство прикладных функций выполняется через интерфейс файловой системы (в том числе и доступ к периферийным устройствам), права доступа к файлам определяют привилегии пользователя в системе.
Файловая подсистема обеспечивает перенаправление запросов, адресованных периферийным устройствам, соответствующим модулям подсистемы ввода/вывода.

**Подсистема управления процессами**.
Запущенная на выполнение программа порождает в системе один или более процессов (или задач).
Подсистема управления процессами контролирует:
1. Создание и удаление процессов.
2. Распределение системных ресурсов (памяти, вычислительных ресурсов) между процессами.
3. Синхронизацию процессов.
4. Межпроцессное взаимодействие.

Очевидно, что в общем случае число активных процессов превышает число процессоров компьютера, но в каждый конкретный момент времени на каждом процессоре может выполняться только один процесс.
Операционная система управляет доступом процессов к вычислительным ресурсам, создавая ощущение одновременного выполнения нескольких задач.

Специальная задача ядра, называемая распорядителем или **планировщиком процессов** (_scheduler_), разрешает конфликты между процессами в конкуренции за системные ресурсы (процессор, память, устройства ввода/вывода).
Планировщик запускает процесс на выполнение, следя за тем, чтобы процесс монопольно не захватил разделяемые системные ресурсы.
Процесс освобождает процессор, ожидая длительной операции ввода/вывода, или по прошествии кванта времени.
В этом случае планировщик выбирает следующий процесс с наивысшим приоритетом и запускает его на выполнение.

**Модуль управления памятью** обеспечивает размещение оперативной памяти для прикладных задач.
Оперативная память является дорогостоящим ресурсом, и, как правило, ее редко бывает "слишком много".
В случае, если для всех процессов недостаточно памяти, ядро перемещает части процесса или нескольких процессов во вторичную память (как правило, в специальную область жесткого диска), освобождая ресурсы для выполняющегося процесса.
Все современные операционные системы реализуют так называемую виртуальную память: процесс выполняется в собственном логическом адресном пространстве, которое может значительно превышать доступную физическую память.
Управление виртуальной памятью процесса также входит в задачи модуля управления памятью.

**Модуль межпроцессного взаимодействия** отвечает за уведомление процессов о событиях с помощью сигналов и обеспечивает возможность передачи данных между различными процессами. 

**Подсистема ввода/вывода** выполняет запросы файловой подсистемы и подсистемы управления процессами для доступа к периферийным устройствам (дискам, магнитным лентам, терминалам и т. д.).
Она обеспечивает необходимую буферизацию данных и взаимодействует с драйверами устройств — специальными модулями ядра, непосредственно обслуживающими внешние устройства.

## Порядок выполнения работы

### 1. Изучение структуры файловой системы и команд pwd, cd и ls

В Linux файлы организованы в виде древовидной структуры, называемой файловой системой.
Каждый файл имеет имя, определяющее его расположение в дереве файловой системы.
Корнем этого дерева является корневой каталог (_root directory_), имеющий имя «/».
Имена всех остальных файлов содержат путь – список каталогов (ветвей), которые необходимо пройти, чтобы достичь файла.

В корневом каталоге Linux-системы обычно находятся только подкаталоги со стандартными именами.
Более того, не только имена, но и тип данных, которые могут попасть в тот или иной каталог, также регламентированы этим стандартом.
Данный стандарт называется _Filesystem Hierarchy Standard_ ("стандартная структура файловых систем").

Краткое описание того, что находится в каждом из подкаталогов корневого каталога:

- `/bin` Название этого каталога происходит от слова "binaries" ("двоичные", "исполняемые").
В этом каталоге находятся исполняемые файлы самых необходимых утилит.
Сюда попадают такие программы, которые могут понадобиться системному администратору или другим пользователям для устранения неполадок в системе или при восстановлении после сбоя.
- `/boot` "Boot" – загрузка системы.
В этом каталоге находятся файлы, необходимые для самого первого этапа - загрузки ядра - и, обычно, само ядро.
Пользователю практически никогда не требуется непосредственно работать с этими файлами.
- `/dev` В этом каталоге находятся все имеющиеся в системе файлы-дырки: файлы особого типа, предназначенные для обращения к различным системным ресурсам и устройствам (англ. "_devices_" - "устройства", отсюда и сокращенное название каталога).
Например, файлы _/dev/ttyN_ соответствуют виртуальным консолям, где _N_ - номер виртуальной консоли.
Данные, введенные пользователем на первой виртуальной консоли, система считывает из файла _/dev/tty1_; в этот же файл записываются данные, которые нужно вывести пользователю на эту консоль.
В файлах-дырках в действительности не хранятся никакие данные, при их помощи данные передаются.
- `/etc` Каталог для системных конфигурационных файлов.
Здесь хранится информация о специфических настройках данной системы: информация о зарегистрированных пользователях, доступных ресурсах, настройках различных программ.
- `/home` Здесь расположены каталоги, принадлежащие пользователям системы - домашние каталоги, отсюда и название "_home_".
Отделение всех файлов, создаваемых пользователями, от прочих системных файлов дает очевидное преимущество: серьезное повреждение системы или необходимость обновления не затронет наиболее ценной информации - пользовательских файлов.
- `/lib` Название этого каталога - сокращение от "_libraries_" (англ. "библиотеки").
Библиотеки - это собрания стандартных функций, необходимых многим программам: операций ввода/вывода, рисования элементов графического интерфейса и т.д.
Чтобы не включать эти функции в текст каждой программы, используются стандартные функции библиотек - это значительно экономит место на диске и упрощает написание программ.
В этом каталоге содержатся библиотеки, необходимые для работы наиболее важных системных утилит (размещенных в `/bin` и `/sbin`).
- `/mnt` Каталог для монтирования (от англ. "mount") - временного подключения файловых систем, например, на съемных носителях. 
- `/proc` В этом каталоге все файлы "виртуальные" - они располагаются не на диске, а в оперативной памяти.
В этих файлах содержится информация о программах (процессах), выполняемых в данный момент в системе.
- `/root` Домашний каталог администратора системы - пользователя root.
Смысл размещать его отдельно от домашних каталогов остальных пользователей состоит в том, что `/home` может располагаться на отдельном устройстве, которое не всегда доступно (например, на сетевом диске), а домашний каталог `/root` должен присутствовать в любой ситуации.
- `/sbin` Каталог для важнейших системных утилит (название каталога - сокращение от "_system binaries_"): в дополнение к утилитам `/bin` здесь находятся программы, необходимые для загрузки, резервного копирования, восстановления системы.
Полномочия на исполнение этих программ есть только у системного администратора.
- `/tmp` Этот каталог предназначен для временных файлов: в таких файлах программы хранят необходимые для работы промежуточные данные.
После завершения работы программы временные файлы теряют смысл и должны быть удалены.
Обычно каталог `/tmp` очищается при каждой загрузке системы.
- `/usr` Здесь можно найти такие же подкаталоги bin, etc, lib, sbin, как и в корневом каталоге.
Однако в корневой каталог попадают только утилиты, необходимые для загрузки и восстановления системы в аварийной ситуации - все остальные программы и данные располагаются в подкаталогах `/usr`.
Прикладных программ в современных системах обычно установлено очень много, поэтому этот раздел файловой системы может быть очень большим.
- `/var` Название этого каталога - сокращение от "_variable_" (англ. "переменные" данные).
Здесь размещаются те данные, которые создаются в процессе работы разными программами и предназначены для передачи другим программам и системам (очереди печати, электронной почты и др.) или для сведения системного администратора (системные журналы, содержащие протоколы работы системы).
В отличие от каталога `/tmp` сюда попадают те данные, которые могут понадобиться после того, как создавшая их программа завершила работу.

Стандарт FHS регламентирует не только перечисленные каталоги, но и их подкаталоги, а иногда даже приводит список конкретных файлов, которые должны присутствовать в определенных каталогах.
Этот стандарт последовательно соблюдается во всех Linux-системах, хотя и не без горячих споров между разработчиками при выходе каждой новой его версии.

Стандартное размещение файлов позволяет и человеку, и даже программе предсказать, где находится тот или иной компонент системы.
Для человека это означает, что он сможет быстро сориентироваться в любой системе Linux (где файловая система организована в соответствии со стандартом) и найти то, что ему нужно.
Для программ стандартное расположение файлов - это возможность организации автоматического взаимодействия между разными компонентами системы.

В Linux все доступное пользователям файловое пространство объединено в единое дерево каталогов, корнем которого является каталог «/».
Таким образом, полное имя любого файла начинается с «/» и не содержит идентификатора устройства, на котором он фактически хранится.
Имя файла является атрибутом файловой системы, а не набора некоторых данных на диске, который не имеет имени как такового.
Каждый файл имеет связанные с ним метаданные (хранящиеся в индексных дескрипторах – _inode_), содержащие все характеристики файла и позволяющие операционной системе выполнять операции, заказанные прикладной задачей: открыть файл, прочитать или записать данные, создать или удалить файл.
В частности, метаданные содержат указатели на дисковые блоки хранения данных файла.
Имя файла в файловой системе является указателем на его метаданные, в то время как метаданные не содержат указателя на имя файла.
Такая архитектура позволяет одному файлу иметь несколько имен в файловой системе. 

Имена жестко связаны с метаданными и, соответственно, с данными файла, в то время как сам файл существует независимо от того, как его называют в файловой системе.
Такая связь имени файла с его данными называется **жесткой связью**.
По определению жесткие связи указывают на один и тот же индексный дескриптор _inode_.
Жесткая связь является естественной формой связи имени файла с его метаданными и не принадлежит к особому типу файла.

Особым типом файла является **символьная связь**, позволяющая косвенно адресовать файл.
В отличие от жесткой связи, символическая связь адресует файл, который, в свою очередь, ссылается на другой файл.
В результате, последний файл адресуется символической связью косвенно.
Данные файла, являющегося символической связью, содержат только имя целевого файла.

Если к файловой системе Linux монтируется файловая система, в которой структуры файла и его метаданных существенно отличаются от Linux, то используется виртуальная файловая система, основанная на представлении метаданных файла в виде, сходном с традиционной семантикой Linux.
Интерфейсом работы с файлами является _vnode_ (от _virtual inode_ — виртуальный индексный дескриптор).
Метаданные всех активных файлов (файлов, на которые ссылаются один или более процессов) представлены в памяти в виде _in-core inode_, в качестве которых в виртуальной файловой системе выступают _vnode_.
Структура данных _vnode_ одинакова для всех файлов, независимо от типа реальной файловой системы, где фактически располагается файл.
Данные _vnode_ содержат информацию, необходимую для работы виртуальной файловой системы, а также неизменные характеристики файла, например, такие как тип файла.

Linux поддерживает три типа прав доступа для владельца, группы и прочих пользователей: на чтение (_read_, обозначается символом _r_), запись (_write_, обозначается символом _w_) и на выполнение (_execute_, обозначается символом _х_).
Права доступа могут быть изменены только владельцем файла или администратором системы.
Для этого используется команда `chmod` (рассмотрите самостоятельно). 

_Замечание:_ проверку результата работы команды `chmod` можно провести только в режиме «обычного» пользователя, так как для администратора атрибуты доступа не проверяются.

К дополнительным атрибутам относятся:
- _t_ – позволяет пользователю удалять только файлы, которыми он владеет или имеет права на запись (используется для каталогов);
- _s_ – установить права доступа запущенного процесса.

#### Задания

Ознакомьтесь по рекомендуемым литературным источникам с организацией файловой системы операционной системы Linux.
Рассмотрите следующие вопросы: 
1. Общая структура файловой системы. 
2. Типы файлов. 
3. Команды для работы с файлами и каталогами.

Необходимо рассмотреть следующие команды (у некоторых команд, чтобы не было ошибок, в скобках указано полное имя, от которого получилось сокращенное): имя текущего каталога – `pwd`, список файлов в каталоге – `ls` (list), изменить текущий каталог – `cd`, установить связи – `ln` (link), копировать – `cp`, удалить – `rm` (remove), распечатать файл – `cat`.

Используя менеджеры файлов и эмулятор терминала, рассмотрите структуру файловой системы.

Отметьте наличие или отсутствие «стандартных» для Linux-систем каталогов (например, `bin`, `etc`, `usr` и т.д.), а также отметьте способы обозначения каталогов, файлов ссылок, как в менеджерах файлов, так и командной строке терминала.

В эмуляторе терминала для получения справки по команде просмотра содержимого директория необходимо использовать ключ `--help` (обратите внимание на использование двух знаков «минус»), например, `ls --help`.

### 2. Изучение файлов типа связь и команд для работы с файлами

Пример использования ссылочного типа файлов приведен в режиме терминала, чтобы попутно рассмотреть команды создания нового каталога `mkdir` и, особенно, команды `cat`, дающей много возможностей по обработке текстового файла.
Все действия при работе с командами записаны очень подробно, чтобы обратить внимание на особенности работы в терминальном режиме.

Для удобства рассмотрения ссылочных файлов создайте в домашнем каталоге новый подкаталог, например, с именем new и перейдите в него.

```
mkdir new
cd new
```

Создайте два текстовых файла (например, с именами txt1, txt2), используя команду `cat`.

```
cat >txt1
первый файл
*нажать комбинацию клавиш Ctrl+Z*
```

Здесь устройством ввода служит клавиатура, вывод перенаправлен в файл с именем txt1.
Как и для большинства команд подобного рода, стандартным устройством ввода будет служить клавиатура, а стандартным устройством вывода – монитор.
Знак «>» указывает, что вывод перенаправлен в файл с именем txt1.
При вводе с клавиатуры можно построчно вводить текст.
Каждая строка завершается при нажатии клавиши «Enter».
Завершение ввода текста – «Ctrl+Z».
Таким образом, в файле txt1 будет содержаться текст «первый файл».

Аналогично можно создать файл txt2.

Просмотрите содержимое каталога командой `ls`, используя два ключа: `i` – для вывода inode и `l` – для использования широкого формата.

```
ls –i –l
2655 -rw-r--r--  1  root  root  22 2009-10-12 08:20  txt1
2656 -rw-r--r--  1  root  root  22 2009-10-12 08:21  txt2
```

Сделайте жесткую ссылку new1 на файл txt1, используя команду `ln`, и опять просмотрите содержимое каталога.

```
ln txt1 new1
ls –i –l
2655  -rw-r--r--  2  root  root  22 2009-10-12 08:20  txt1
2656  -rw-r--r--  1  root  root  22 2009-10-12 08:21  txt2
2655  -rw-r--r--  2  root  root  22 2009-10-12 08:20  new1
```

Обратите внимание на то, что у файла new1 тот же inode (2655) и совпадает время создания.
В третьей колонке число 2 показывает коли-чество ссылок на файл.

Измените содержимое файла new1 и убедитесь, что файлы txt1 и new1 – это один и тот же файл на диске, только у него два имени.
Также проверьте, что жесткая ссылка не нарушается при перемещении файлов по каталогам, а также то, что нельзя делать жесткие ссылки на каталоги.

Символьную ссылку можно делать как на файлы, так и на каталоги. Например, можно сделать ссылку на файл txt2.

```
ln -s 2 new2
```

Результатом будет новый файл со своим inode и временем создания.
Количество ссылок на файл txt2 не изменится.
Размер файла соответствует длине имени файла, на который делается ссылка.
Обращение к файлу new2 будет переадресовано на файл txt2. 

```
2887  lrwxrwxrwx  1  root  root  1  2009-10-12 08:23  new2 -> 2
```

Можно даже сделать символьную связь из каталога на сам этот каталог.
Рассмотрите, что произойдет при многократном переходе в этот каталог.

```
ln -s ../new newdir	
```

Проверьте глубину символьных связей в данной системе.
Найдите места расположения ссылок на компилятор с языка Си и расположение остальных каталогов и файлов, относящихся к компилятору.

### 3. Монтирование файловых систем

WIP

### 4. Системные вызовы для работы с файлами

Из курса программирования на языке Cи известны функции работы с файлами из стандартной библиотеки ввода-вывода, такие как `fopen()`, `fread()`, `fwrite()` и т.д.
Эти функции входят как неотъемлемая часть в стандарт ANSI на язык Cи и позволяют программисту получать информацию из файла или записывать ее в файл.
С точки зрения потоковой модели операции, определяемые функциями стандартной библиотеки ввода-вывода, не являются потоковыми операциями, так как каждая из них требует наличия некоторой структуры передаваемых данных.
В операционной системе Linux эти функции представляют собой надстройку (сервисный интерфейс) над системными вызовами, осуществляющими прямые потоковые операции обмена информацией между процессом и файлом и не требующими никаких знаний о том, что она содержит.
В системных вызовах `open()`, `read()`, `write()` и `close()`, которые применяются для такого обмена, используется понятие файлового дескриптора.
Информация о файлах, используемых процессом, входит в состав его системного контекста и хранится в его блоке управления – PCB.
В операционной системе Linux можно упрощенно полагать, что информация о файлах, с которыми процесс осуществляет операции потокового обмена, наряду с информацией о потоковых линиях связи, соединяющих процесс с другими процессами и устройствами ввода-вывода, хранится в некотором массиве, получившем название **таблицы открытых файлов** или **таблицы файловых дескрипторов**.
Индекс элемента этого массива, соответствующий определенному потоку ввода-вывода, получил название **файлового дескриптора** для этого потока.
Таким образом, файловый дескриптор представляет собой небольшое целое неотрицательное число, которое для текущего процесса в данный момент времени однозначно определяет некоторый действующий канал ввода-вывода.
Некоторые файловые дескрипторы на этапе старта любой программы ассоциируются со стандартными потоками ввода-вывода.
Так, например, файловый дескриптор 0 соответствует **стандартному потоку ввода**, файловый дескриптор 1 – **стандартному потоку вывода**, файловый дескриптор 2 – **стандартному потоку для вывода ошибок**.
В нормальном интерактивном режиме работы стандартный поток ввода связывает процесс с клавиатурой, а стандартные потоки вывода и вывода ошибок – с текущим терминалом.

Системный вызов `open` предназначен для выполнения операции открытия файла и, в случае ее удачного осуществления, возвращает файловый дескриптор открытого.
Прототип системного вызова open:

```
#include <fcntl.h>
int open(char *path, int flags);
int open(char *path, int flags, int mode);
```

Параметр _path_ является указателем на строку, содержащую полное или относительное имя файла.
Параметр _flags_ может принимать одно из следующих трех значений:

- `O_RDONLY` – если над файлом в дальнейшем будут совершаться только операции чтения; 
- `O_WRONLY` – если над файлом в дальнейшем будут осуществляться только операции записи; 
- `O_RDWR` – если над файлом будут осуществляться и операции чтения, и операции записи.

Каждое из этих значений может быть скомбинировано посредством операции "побитовое или ( | )" с одним или несколькими флагами:

- `O_CREAT` – если файла с указанным именем не существует, он должен быть создан; 
- `O_EXCL` – применяется совместно с флагом O_CREAT. 
При совместном их использовании и существовании файла с указанным именем, открытие файла не производится и констатируется ошибочная ситуация; 
- `O_NDELAY` – запрещает перевод процесса в состояние ожидание при выполнении операции открытия и любых последующих операциях над этим файлом; 
- `O_APPEND` – при открытии файла и перед выполнением каждой операции записи (если она, конечно, разрешена) указатель текущей позиции в файле устанавливается на конец файла; 
- `O_TRUNC` – если файл существует, уменьшить его размер до 0, с сохранением существующих атрибутов файла, кроме, быть может, времен последнего доступа к файлу и его последней модификации.

Параметр _mode_ устанавливает атрибуты прав доступа различных категорий пользователей к новому файлу при его создании.
Он обязателен, если среди заданных флагов присутствует флаг `O_CREAT`, и может быть опущен в противном случае.
Этот параметр задается как сумма следующих восьмеричных чисел _X00+0X0+00X_.
Первое число определяет права доступа владельца, второе – группы, третье – других пользователей.
Каждая восьмеричная цифра, обозначенная как «X», представляет собой триаду двоичных цифр, соответствующих правам доступа _rwx_.

Системные вызовы `read` и `write` предназначены для осуществления потоковых операций ввода (чтения) и вывода (записи) информации над каналами связи, описываемыми файловыми дескрипторами, т.е. для файлов, pipe, FIFO и socket.
Прототипы системных вызовов `read` и `write`:

```
#include <sys/types.h>
#include <unistd.h>
size_t read(int fd, void *addr, size_t nbytes);
size_t write(int fd, void *addr, size_t nbytes);
```

Параметр _fd_ является файловым дескриптором созданного ранее потокового канала связи.
Параметр _addr_ представляет собой адрес области памяти, начиная с которого будет браться информация для передачи или размещаться принятая информация.
Параметр _nbytes_ определяет количество передаваемых (для вызова `write`) или принимаемых байтов (для вызова `read`).
Возвращаемое значение – количество реально принятых (`read`) или переданных (`write`) байтов.

Системный вызов `close(fd)` производит действие, обратное по отношению к вызову open.
Возвращаемое значение – 0, если операция прошла успешно, и -1 в случае возникновения ошибки.

Системные вызовы `stat`, `fstat` и `lstat` служат для получения информации об атрибутах файла.
Прототипы системных вызовов:

```
#include <sys/stat.h>
#include <unistd.h>
int stat(char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(char *filename, struct stat *buf);
```

Системный вызов `stat` читает информацию об атрибутах файла, на имя которого указывает параметр _filename_, и заполняет ими структуру, расположенную по адресу _buf_.
Имя файла должно быть полным, либо должно строиться относительно той директории, которая является текущей для процесса, совершившего вызов.
Если имя файла относится к файлу типа "связь", то читается информация об атрибутах файла, на который указывает символическая связь.

Системный вызов `lstat` идентичен системному вызову `stat` за одним исключением: если имя файла относится к файлу типа "связь", то читается информация о самом файле типа "связь".

Системный вызов `fstat` идентичен системному вызову `stat`, только файл задается не именем, а своим файловым дескриптором (естественно, файл к этому моменту должен быть открыт).

Для системных вызовов `stat` и `lstat` процессу не нужны никакие права доступа к указанному файлу, но могут понадобиться права для поиска во всех директориях, входящих в специфицированное имя файла.

Структура `stat` в различных версиях Linux может быть описана по-разному.
В Linux она содержит следующие поля: 

```
struct stat {
    dev_t st_dev;   /* устройство, на котором расположен файл */
    ino_t st_ino;   /* номер индексного узла для файла */ 
    mode_t st_mode;   /* тип файла и права доступа к нему */
    nlink_t st_nlink;   /* счетчик числа жестких связей */
    uid_t st_uid;   /* идентификатор пользователя владельца */
    gid_t st_gid;   /* идентификатор группы владельца */
    dev_t st_rdev;  /*тип устройства для специальных файлов устройств*/
    off_t st_size;   /* размер файла в байтах  */
    unsigbed long st_blksize;   /* размер блока для файловой системы */
    unsigned long st_blocks;   /* число выделенных блоков */
    time_t st_atime;   /* время последнего доступа к файлу */
    time_t st_mtime;  /* время последней модификации файла */
    time_t st_ctime;   /* время создания файла */
}
```

Для определения типа файла можно использовать следующие логиче-ские макросы, применяя их к значению поля _st_mode_:

- `S_ISLNK(m)` – файл типа "связь"? 
- `S_ISREG(m)` – регулярный файл? 
- `S_ISDIR(m)` – директория? 
- `S_ISCHR(m)` – специальный файл символьного устройства? 
- `S_ISBLK(m)` – специальный файл блочного устройства? 
- `S_ISFIFO(m)` – файл типа FIFO? 
- `S_ISSOCK(m)` – файл типа "socket"?

Младшие 9 бит поля st_mode определяют права доступа к файлу подобно тому, как это делается в маске создания файлов текущего процесса.

Системные вызовы для создания связи: `link`, `symlink`, `unlink`.

```
#include <unistd.h>
int link(char *pathname, char *linkpathname);
int symlink(char *pathname, char *linkpathname);
int unlink(char *pathname);
```

#### Задание

Рассмотренные ранее по пунктам 1-3 действия над файлами, реализуйте в программе на языке Си с помощью системных вызовов.

### 5. Системные вызовы для работы с директориями (каталогами)

```
#include <dirent.h>
DIR *opendir (char *dirname);
struct dirent *readdir(DIR *dirp);
struct dirent *rewindir(DIR *dirp);
int closedir(DIR *dirp);
```

Функция `opendir` служит для открытия потока информации для директории.
Тип данных `DIR` представляет собой некоторую структуру данных, описывающую такой поток.
Функция `opendir` позиционирует поток на первой записи директории.
С точки зрения программиста в этом интерфейсе директория представляется как файл последовательного доступа, над которым можно совершать операции чтения очередной записи и позиционирования на начале файла.

Чтение очередной записи из директории осуществляет функция `readdir()`, одновременно позиционируя указатель на начале следующей записи (если она, конечно, существует).

Для операции нового позиционирования на начале директории (при необходимости) применяется функция `rewinddir()`.

После окончания работы с директорией ее необходимо закрыть с помощью функции `closedir()`.

Тип данных `struct dirent` представляет собой некоторую структуру данных, описывающую одну запись в директории.
Поля этой записи сильно варьируются от одной файловой системы к другой, но одно из полей всегда присутствует в ней.
Это поле `char d_name[]` неопределенной длины, не превышающей значения _NAME_MAX+1_, которое содержит символьное имя файла, завершающееся символом конца строки.

Данные, возвращаемые функцией `readdir`, переписываются при очередном вызове этой функции для того же самого потока директории.

#### Задание

Используя системные вызовы для работы с файлами и директориями, реализуйте программу на языке Си, позволяющую сделать распечатку содержимого каталога, указав тип файла и права доступа (аналог команды `ls` с ключом `-l`).
Задача повышенной сложности – рекурсивная распечатка содержимого вложенных каталогов.

### 6. Системные вызовы для работы с файлами, отображаемыми в память

С точки зрения программиста работа с такими файлами выглядит следующим образом: 

- Отображение файла из пространства имен в адресное пространство процесса происходит в два этапа: сначала выполняется отображение в дисковое пространство, а уже затем из дискового пространства в адресное.
Поэтому вначале файл необходимо открыть, используя обычный системный вызов `open()`. 
- Вторым этапом является отображение файла целиком или частично из дискового пространства в адресное пространство процесса.
Для этого используется системный вызов `mmap()`.
Файл после этого можно закрыть, выполнив системный вызов `close()`, так как необходимая информация о расположении файла на диске сохраняется в других структурах данных при вызове `mmap()`.

```
#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h> 
void *mmap (void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

Параметр _fd_ является файловым дескриптором файла, отображаемого в адресное пространство (возвращает системный вызов `open()`).
Значение параметра start чаще всего выбирается равным `NULL`, позволяя операционной системе самой выбрать начало области адресного пространства, в которую будет отображен файл.

В память будет отображаться часть файла, начиная с позиции внутри его, заданной значением параметра _offset_ – смещение от начала файла в байтах, и длиной, равной значению параметра _length_ (тоже в байтах).
Значение параметра _length_ может и превышать реальную длину от позиции _offset_ до конца существующего файла.
На поведении системного вызова это никак не отразится, но в дальнейшем при попытке доступа к ячейкам памяти, лежащим вне границ реального файла, возникнет сигнал `SIGBUS` (реакция на него по умолчанию – прекращение процесса с образованием core файла).

Параметр _flags_ определяет способ отображения файла в адресное пространство.
Рассмотрим только два его возможных значения: `MAP_SHARED` и `MAP_PRIVATE`.
Если в качестве его значения выбрано `MAP_SHARED`, то полученное отображение файла впоследствии будет использоваться и другими процессами, вызвавшими `mmap` для этого файла с аналогичными значениями параметров, а все изменения, сделанные в отображенном файле, будут сохранены во вторичной памяти.
Если в качестве значения параметра _flags_ указано `MAP_PRIVATE`, то процесс получает отображение файла в свое монопольное распоряжение, но все изменения в нем не могут быть сохранены.

Параметр _prot_ определяет разрешенные операции над областью памяти, в которую будет отображен файл.
В качестве его значения можно использовать значения `PROT_READ` (разрешено чтение), `PROT_WRITE` (разрешена запись) или их комбинацию через операцию "побитовое или".

Необходимо отметить две существенные особенности системного вызова, связанные с этим параметром:

1. Значение параметра prot не может быть шире, чем операции над файлом, заявленные при его открытии в параметре _flags_ системного вызова `open()`. 
2. В результате ошибки в операционной системе Linux при работе на 486-х и 586-х процессорах попытка записать в отображение файла, открытое только для записи, более 32-х байт одновременно приводит к ошибке (возникает сигнал о нарушении защиты памяти).

Системный вызов munmap служит для прекращения отображения memory mapped файла в адресное пространство вычислительной системы.
Если при системном вызове `mmap()` было задано значение параметра _flags_, равное `MAP_SHARED`, и в отображении файла была разрешена операция записи (в параметре prot использовалось значение `PROT_WRITE`), то `munmap` синхронизирует содержимое отображения с содержимым файла во вторичной памяти.
После его выполнения области памяти, использовавшиеся для отображения файла, становятся недоступны текущему процессу.

```
#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h> 
int munmap (void *start, size_t length);
```

Параметр _start_ является адресом начала области памяти, выделенной для отображения файла, т.е. значением, которое вернул системный вызов `mmap()`.
Параметр _length_ определяет ее длину, и его значение должно совпадать со значением соответствующего параметра в системном вызове `mmap()`.

Программа, приведенная ниже, создает файл, отображает его в адресное пространство процесса и заносит в него информацию с помощью обычных операций языка Си.
Обратите внимание на необходимость увеличения размера файла перед его отображением.
Созданный файл имеет нулевой размер, и если его с этим размером отобразить в память, то мы сможем записать в него или прочитать из него не более 0 байт, т.е. ничего.
Для увеличения размера файла использован системный вызов `ftruncate()`, хотя это можно было бы сделать и любым другим способом.

```
int main(void)
{
    int fd; /* Файловый дескриптор */
    size_t length; /* Длина отображаемой части файла */
    int i; 
/* struct A – тип  данных для заполнения файла, 
    ptr – начальный адрес выделенной области памяти, 
    tmpptr – указатель для перемещения внутри области памяти. */
    struct A {
        double f;
        double f2; } *ptr, *tmpptr;
/* Открываем файл */
    fd = open("mapped.dat", O_RDWR | O_CREAT, 0666);
/* Вычисляем будущую длину файла для записи в него 1000 структур */
    length = 1000*sizeof(struct A);
/* Увеличиваем длину файла с помощью вызова ftruncate(). */
    ftruncate(fd,length);
/* Файл отображаем с его начала (offset = 0) и до конца (length = длине файла). */
    ptr = (struct A *) mmap (NULL, length, 
	PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0);
/* Файловый дескриптор нам более не нужен, и мы его закрываем */
    close(fd);
/* Если отобразить файл не удалось – сообщаем об ошибке */
    if ( ptr == MAP_FAILED ) 
      { printf("Mapping failed!\n"); exit(2);  }
/* В цикле заполняем образ файла числами */
    tmpptr = ptr;
    for(i = 1; i <=100000; i++)
      {tmpptr->f = i;
       tmpptr->f2 = i*i;
       tmpptr++; }
/* Прекращаем отображать файл в память, записываем содержимое отображения на диск и освобождаем память. */
    munmap((void *)ptr, length);
    return 0; 
}
```

#### Задания

Модифицируйте программу так, чтобы она отображала файл mapped.dat, записанный программой из примера.

Определите размер файла, который можно отобразить в память.

Проверьте, можно ли отобразить в одну и ту же область памяти несколько файлов.

Реализуйте указанные действия другими средствами языка Си.
