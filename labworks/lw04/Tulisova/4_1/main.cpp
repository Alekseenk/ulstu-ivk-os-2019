//Лабораторная работа №4
//Тема:Потоковое межпроцессное взаимодействие.Межпроцессное взаимодействие через канал pipe.
//Задание: модифицируйте пример для связи между собой двух
//родственных процессов, исполняющих разные программы.
//Выполнила студентка гр. ИСТбд-22 Тулисова А.А.
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
using namespace std;
//Pipe представляет собой область памяти, недоступную пользовательским
//процессам напрямую, зачастую организованную в виде кольцевого буфера.
//Прочитанная информация немедленно из него удаляется и не может быть прочитана повторно
int main()
{
	int fd[2], result;
	size_t size;
	char string[] = "Hello, world!";//Строка для записи
	char resstring[14];//Строка для чтения
	int channel=pipe(fd);   // Создаём канал с двумя файловыми дескрипторами - потоки ввода и вывода
    if (channel == 0)         //ошибка -1 ,0 при нормальном исполнении
    {                  //fd[0]-дескриптор, соответствующий входному потоку данных
                       //канала и позволяющий выполнять только операцию чтения,
                       //fd[1] - будет занесен файловый дескриптор, соответствующий
                     //выходному потоку данных и позволяющий выполнять только операцию записи
        result = fork(); // Порождаем дочерний процесс
        if (result > 0)
        {
            printf("Работу начал родительский процесс\n");
            // Родитель записывает строку в канал
            close(fd[0]);
            printf("Начали запись строки...\n");
            size = write(fd[1],string, 14); //Запись всей строки вместе с признаком конца строки в канал
            printf("Записали строку...\n");
            close(fd[1]); // Выходной поток закрываем
            //Если есть процессы, у которых этот pipe открыт для записи, то системный вызов read блокируется и
            //ждет появления информации.
            printf("Закрыли выходной поток! \n");
        }
        else
         {
            printf("Работу начал дочерний процесс\n");
            // Потомок читает строку из канала через входной поток
            close(fd[1]);
            printf("Начали чтение строки...\n");
            size = read(fd[0], resstring, 14); // Если читается из пустого канала, то процесс блокируется
			//(write,read - блокирующие системные вызовы)
            printf("Прочитали строку...\n");
            printf("Прочитанная строка: \n");
            printf("%s\n", resstring);// Печать прочитанной строки
            close(fd[0]); // Входной поток закрываем
            printf("Закрыли входной поток! \n");
         }
	}
	else printf("Ошибка создания канала...\n");
    return 0;
    //Когда все процессы, использующие pipe,закрывают все ассоциированные с ним файловые дескрипторы,
	//операционная система ликвидирует pipe.
}
