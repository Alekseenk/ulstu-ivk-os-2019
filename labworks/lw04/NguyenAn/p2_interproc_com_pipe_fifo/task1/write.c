#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define AUTHOR "Нгуен Хыу Ан"
#define GROUP "ИСТбд-21"

/**
 * Для организации потокового взаимодействия любых процессов в ОС Linux
 * применяется средство связи, получившее название FIFO.
 * FIFO подобен pipe, за одним исключением: данные о расположении FIFO
 * в адресном пространстве ядра и его состоянии процессы могут получать
 * не через родственные связи, а через файловую систему. Для этого при
 * созд. именованного канала заводится файл спец. типа (файл-метка), к которому 
 * обращаются процессы.
 * Для создания FIFO используется системный вызов mknod().
 * Для работы с ним используются системные вызовы read(), write(), close()
 * Время жизни FIFO в адресном пространстве не должна превышать время жизни
 * последнего из использовавших его процессов.
 * После того как все процессы, работавшие с FIFO, закрывают все файловые
 * дескрипторы, связанные с ним, система высвобождает ресурсы, выделенные
 * под FIFO. При этом файл-метка остаётся на диске.
 *
 * #include <sys/stat.h>
 * #include <unistd.h>
 *
 * int mknod(const char *pathname, mode_t mode, dev_t dev);
 *
 * Параметры: const char *pathname - указатель на строку, содержащий полный путь с именем файла
 * 			             или относительный путь
 * 	      mode_t mode - определяет атрибут прав доступа файла для разных категории пользователей
 * 	      		    Этот параметр должен задаваться как результат побитовой операции ИЛИ 
 * 	      		    значения S_IFIFO
 * 	      dev_t dev - если тип файла S_IFCHR или S_IFBLK, то dev определяет
 * 	                  major и minor числа созданного файла спец. типа, (mkdev(3)) 
 * 	                  иначе игнорируется
 * Возвращает: если прошло успешно 0, иначе -1
 *
 **/

void print_author_and_group() {
    printf("Лабораторная работа №4\n Выполнил студент %s\n группы %s \n\n", AUTHOR, GROUP);
}

int main(int argc, char **argv) {
    int fd, mknod_res;
    char *res_str = "It's my message!";
    const char *pathfile = "./file.fifo"; 

    print_author_and_group();
    
    /**
     * r - read  = 4
     * w - write = 2
     * x - exec  = 1
     * 0674
     * 1 бит - остальные пользователи
     * 2 бит - группа пользователей
     * 3 бит - владелец
     **/
    if (access(pathfile, F_OK) == -1) {
	(void)umask(0);
	mknod_res = mknod(pathfile, S_IFIFO | 0666, (dev_t)0);
	if (mknod_res == -1) {
	    printf("Создание FIFO - неудача.");
	    exit(1);
	}	
    }

    /**
     * Если FIFO открывается только для записи, и флаг O_NDELAY не задан ->
     * то процесс, вызвавший mknod(), блокируется до тех пор пока другой процесс
     * не откроет его для чтения.  
     **/
    printf("Канал FIFO открыт для записи.\n");
    fd = open(pathfile, O_WRONLY);
     
    printf("Этот процесс записал данные в канал FIFO.\n");
    write(fd, res_str, 32);
    
    printf("Канал FIFO закрыт.");
    close(fd);

    printf("Канал удалён.");
    remove(pathfile);

    return 0;
}
